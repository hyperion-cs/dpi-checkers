<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RU :: IPv4 Whitelisted Subnets</title>
  <style>
    body {
      font: 1em/1.6 -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f7fa;
      color: #333;
    }

    .header {
      font-size: 1.2em;
      margin: 0 0.5em 0;
      color: #1a1a1a;
    }

    .status-br::after {
      content: "";
    }

    #status {
      font-weight: 600;
    }

    .status-non-cached {
      color: #1a1a1a;
    }

    .status-ready {
      color: #28a745;
    }

    .status-working {
      color: #9200ff;
    }

    .status-error {
      color: #dc3545;
    }

    .btn {
      font-size: 1.2em;
      padding: .8em 1em;
      background: #1a1a1a;
      color: #fff;
      border: 0;
      border-radius: 6px;
      cursor: pointer;
      line-height: 1;
      transition: background .3s, transform .1s;
    }

    .btn:hover {
      background: #6c757d;
      transform: translateY(-2px);
    }

    .btn:disabled {
      background: #6c757d;
      cursor: not-allowed;
    }

    hr {
      border-top: 1px solid #e0e0e0;
      margin: 20px 0;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      background: #fff;
      box-shadow: 0 2px 4px rgba(0, 0, 0, .1);
      border-radius: 8px;
      overflow: hidden;
      margin-top: 0.2em;
    }

    th,
    td {
      padding: 4px 15px;
      text-align: left;
      border-bottom: 1px solid #e0e0e0;
    }

    th {
      background: #9200ff;
      color: #fff;
      font-weight: 600;
    }

    tr:last-child td {
      border-bottom: 0;
    }

    .ok {
      color: #28a745;
      font-weight: 500;
    }

    .bad {
      color: #dc3545;
      font-weight: 500;
    }

    #log {
      background: #1a1a1a;
      color: #d4d4d4;
      padding: 15px;
      border-radius: 6px;
      font: .9em 'Courier New', Courier, monospace;
      max-height: 300px;
      overflow-y: auto;
      margin: 0.5em 0;
      overflow-wrap: anywhere;
    }

    .footer {
      margin-top: 20px;
      font-size: .9em;
      color: #555;
    }

    a {
      color: #9200ff;
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    @media (max-width: 600px) {
      body {
        padding: 10px;
      }

      .header {
        font-size: 1em;
      }

      .btn {
        font-size: 1em;
      }

      table {
        font-size: .9em;
      }

      th,
      td {
        padding: 3px 8px;
      }

      #log {
        padding: 7px;
      }

      .status-br::after {
        content: "\A";
        white-space: pre;
      }

      .container {
        display: flex;
        justify-content: center;
        align-items: center;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <div>
      <button id="cache-subnets-btn" class="btn">Cache</button>
      <button id="check-subnets-btn" class="btn" disabled>Check üî•</button>
      <button id="save-btn" class="btn" disabled>üíæ</button>
      <span class="status-br"></span>
      <span class="header">
        Status: <span id="status" class="status-non-cached">Ready (non-cached ‚ö†Ô∏è)</span>
      </span>
    </div>
  </div>
  <table id="results">
    <tr>
      <th>#</th>
      <th>Provider</th>
      <th>Whitelisted Subnet</th>
    </tr>
  </table>
  <pre id="log"></pre>
  <div class="footer">
    üí° DPI[ipv4 whitelisted subnets] /
    This checker (and others) are available in <b><a href="https://github.com/hyperion-cs/dpi-checkers"
        target="_blank">this</a></b> open-source repository.
  </div>

  <script>
    const TEST_SUITE = [
      { "name": "Yandex", "asns": ["13238", "44534", "200350", "202611", "208398", "208795", "210656", "212066", "215013", "215109"] },
      { "name": "VK", "asns": ["28709", "47541", "47542", "47764", "60863", "62243", "199295", "207581"] },
      { "name": "EdgeCenter", "asns": ["201589", "207059", "210756"] },
    ];

    let TIMEOUT_MS = 5000;
    let SUBNET_SAMPLE_SIZE = 25;
    let SUBNET_ALIVE_MIN = 3;
    let SUBNET_ONLY_24_PREFIX = true;

    (function getParamsHandler() {
      const params = new URLSearchParams(window.location.search);

      TIMEOUT_MS = parseInt(params.get("timeout")) || TIMEOUT_MS;
      SUBNET_SAMPLE_SIZE = parseInt(params.get("sn_sample_size")) || SUBNET_SAMPLE_SIZE;
      SUBNET_ALIVE_MIN = parseInt(params.get("sn_alive_min")) || SUBNET_ALIVE_MIN;

      let sn_only_24_prefix = params.get("sn_only_24_prefix");
      if (sn_only_24_prefix !== null) {
        SUBNET_ONLY_24_PREFIX = sn_only_24_prefix === "true";
      }
    })();

    const fetchOpt = s => ({
      method: "HEAD",
      credentials: "omit",
      cache: "no-store",
      signal: s,
      redirect: "manual",
      keepalive: true
    });

    const cacheSubnetsButton = document.getElementById("cache-subnets-btn");
    const checkSubnetsButton = document.getElementById("check-subnets-btn");
    const saveButton = document.getElementById("save-btn");

    const status = document.getElementById("status");
    const log = document.getElementById("log");
    const resultsTable = document.getElementById("results");
    let resultsData = [];
    let resultsCount = 0;
    let cachedSubnets = {};

    const logPush = (level, prefix, msg) => {
      const now = new Date();
      const ts = now.toLocaleTimeString([], { hour12: false }) + "." + now.getMilliseconds().toString().padStart(3, "0");
      log.textContent += `[${ts}] ${prefix ? prefix + "/" : ""}${level}: ${msg}\n`;
      log.scrollTop = log.scrollHeight;
    };

    const timeElapsed = t0 => `${(performance.now() - t0).toFixed(1)} ms`;

    const getUniqueUrl = url => {
      return url.includes('?') ? `${url}&t=${Math.random()}` : `${url}?t=${Math.random()}`;
    };

    const checkSubnet = async (provider, cidr) => {
      const prefix = `Subnet checker[${provider} => ${cidr}]`;
      logPush("INFO", prefix, `Started`);

      const ips = getSubnetSample(cidr, SUBNET_SAMPLE_SIZE);
      const earlyAbortCtrl = new AbortController();
      const tasks = []

      const ref = { aliveCount: 0 }; // Shares between tasks.

      for (const ip of ips) {
        tasks.push(checkIpv4Host(ip, earlyAbortCtrl, ref));
      }
      const aliveCount = (await Promise.all(tasks)).filter(x => x).length;

      if (aliveCount > 0) {
        const row = resultsTable.insertRow();
        const numCell = row.insertCell();
        const providerCell = row.insertCell();
        const subnetCell = row.insertCell();

        numCell.textContent = ++resultsCount;
        providerCell.innerHTML = `<b>${provider}</b>`;

        subnetCell.textContent = aliveCount >= SUBNET_ALIVE_MIN ? `${cidr} ‚úÖ` : `${cidr} ‚ö†Ô∏è`;
        resultsData.push({ provider, cidr, aliveCount });
      }

      logPush("INFO", prefix, `Done (alive: ${aliveCount}).`);
    }

    const checkSubnets = async () => {
      const t0 = performance.now();
      const prefix = `Subnets checker`;
      logPush("INFO", prefix, `Started`);

      for (let i = resultsTable.rows.length - 1; i > 0; i--) {
        resultsTable.deleteRow(i);
      }

      resultsCount = 0;
      resultsData = [];
      const subnetsTotal = Object.values(cachedSubnets).flat().length;
      let subnetsChecked = 0;

      checkSubnetsButton.disabled = true;
      cacheSubnetsButton.disabled = true;
      saveButton.disabled = true;
      checkSubnetsButton.textContent = "...";
      status.className = "status-working";

      for (const [provider, subnets] of Object.entries(cachedSubnets)) {
        for (const s of subnets) {
          status.textContent = `Subnets checking (${subnetsChecked++}/${subnetsTotal}) ‚è∞`;
          await checkSubnet(provider, s);
        }
      }

      status.textContent = "Ready (cached ‚ö°)";
      status.className = "status-ready";
      checkSubnetsButton.disabled = false;
      cacheSubnetsButton.disabled = false;
      checkSubnetsButton.textContent = "Check üî•";

      if (resultsCount > 0) {
        saveButton.disabled = false;
      }

      console.log("result data", resultsData);
      logPush("INFO", prefix, `Done (found: ${resultsCount}, elapsed: ${timeElapsed(t0)}).`);
    }

    const cacheSubnets = async () => {
      const t0 = performance.now();
      const prefix = `Subnets cacher`;
      log.textContent = "";
      sessionStorage.clear();

      logPush("INFO", prefix, `Started`);

      status.textContent = "Subnets caching ‚è∞";
      status.className = "status-working";
      cacheSubnetsButton.disabled = true;
      cacheSubnetsButton.textContent = "...";

      for (let i = results.rows.length - 1; i > 0; i--) {
        results.deleteRow(i);
      }

      try {
        for (let t of TEST_SUITE) {
          const r = await fetchProviderIpv4Subnets(t);
          cachedSubnets[t.name] = r;
        }

        console.log("cached subnets", cachedSubnets);
        localStorage.setItem("ipv4-whitelisted-subnets_cachedSubnets", JSON.stringify(cachedSubnets));

        checkSubnetsButton.disabled = false;
        cacheSubnetsButton.disabled = false;
        cacheSubnetsButton.textContent = "Cache";
        status.className = "status-ready";
        status.textContent = "Ready (cached ‚ö°)";

        logPush("INFO", prefix, `Cached in ${timeElapsed(t0)}.`);
      } catch (e) {
        checkSubnetsButton.disabled = true;
        cacheSubnetsButton.disabled = false;
        cacheSubnetsButton.textContent = "Cache";
        status.textContent = "Unexpected caching error ‚ö†Ô∏è";
        status.className = "status-error";
        logPush("ERR", prefix, `Unexpected caching error => ${e}`);
      }
    };

    // Returns N random unique hosts from a subnet based on CIDR.
    const getSubnetSample = (cidr, n) => {
      const [ip, maskStr] = cidr.split('/');

      const ipToUint32 = s => {
        const [a, b, c, d] = s.split('.').map(Number);
        return a * 2 ** 24 + b * 2 ** 16 + c * 2 ** 8 + d;
      };

      const uint32ToIp = x => {
        const a = Math.floor(x / 2 ** 24) & 255;
        const b = Math.floor(x / 2 ** 16) & 255;
        const c = Math.floor(x / 2 ** 8) & 255;
        const d = x & 255;
        return `${a}.${b}.${c}.${d}`;
      };

      const blockSize = 2 ** (32 - Number(maskStr));
      const swap = new Map();
      const result = new Array(n);

      for (let i = 0; i < n; i++) {
        const r = i + Math.floor(Math.random() * (blockSize - i - 2));

        const pick = swap.has(r) ? swap.get(r) : r;
        swap.set(r, swap.has(i) ? swap.get(i) : i);

        result[i] = uint32ToIp(Math.floor(ipToUint32(ip) / blockSize) * blockSize + pick + 1);
      }

      return result;
    };

    // Any response from the server (including HTTP or CORS errors) is considered correct. Only a timeout is a signal of restrictions.
    const checkIpv4Host = async (ip, earlyAbortCtrl, ref) => {
      if (ref.aliveCount >= SUBNET_ALIVE_MIN) {
        earlyAbortCtrl.abort();
        logPush("INFO", prefix, `Early abort ‚è≠Ô∏è`);
        return false;
      }

      const timeoutCtrl = new AbortController();
      const t = setTimeout(() => timeoutCtrl.abort(), TIMEOUT_MS);
      const prefix = `Host checker[${ip}]`;

      const abortSignals = AbortSignal.any([earlyAbortCtrl.signal, timeoutCtrl.signal]);

      let result = true;
      try {
        logPush("INFO", prefix, `Started`);

        await fetch(getUniqueUrl(`https://${ip}/`), fetchOpt(abortSignals));
      } catch (e) {
        if (e.name === "AbortError") result = false;
      } finally {
        clearTimeout(t);
      }

      if (result) {
        ref.aliveCount++;
      }

      if (ref.aliveCount >= SUBNET_ALIVE_MIN) {
        earlyAbortCtrl.abort();
      }

      logPush("INFO", prefix, `${result ? "Alive ‚úÖ" : (earlyAbortCtrl.signal.aborted ? "Early abort ‚è≠Ô∏è" : "Dead üíÄ")}.`);
      return result;
    }

    const isIpv4Cidr = s => s.includes('.') && s.includes('/');

    const fetchAsIpv4Subnets = async (asn) => {
      const prefix = `AS IPv4 subnets fetcher[AS${asn}]`;
      const RIPE_API_URL = "https://stat.ripe.net/data/";

      try {
        logPush("INFO", prefix, `Started`);
        const prefixes = (await (await fetch(RIPE_API_URL + "announced-prefixes/data.json?resource=" + asn)).json()).data.prefixes
          .map(x => x.prefix)
          .filter(x => isIpv4Cidr(x));

        logPush("INFO", prefix, `Done (total: ${prefixes.length}).`);
        return prefixes;
      } catch (err) {
        throw prefix + err;
      }
    }

    const fetchProviderIpv4Subnets = async (provider) => {
      const prefix = `Provider IPv4 subnets fetcher[${provider.name}]`;

      logPush("INFO", prefix, `Started`);
      const tasks = [];
      for (let i = 0; i < provider.asns.length; i++) {
        tasks.push(fetchAsIpv4Subnets(provider.asns[i]));
      }

      const all = (await Promise.all(tasks)).flat();
      const merged = [...new Set(all)];
      let suitable = merged;

      if (SUBNET_ONLY_24_PREFIX) {
        suitable = merged.filter(x => x.split('/')[1] == "24");
      }

      logPush("INFO", prefix, `Done (all: ${all.length}, merged: ${merged.length}, suitable: ${suitable.length}).`);
      return suitable;
    }

    const saveResults = () => {
      const content = "provider;cidr;aliveCount\n" + resultsData.map(x => `${x.provider};${x.cidr};${x.aliveCount}`).join("\n");
      const blob = new Blob([content], {
        type: "text/csv;charset=utf-8"
      });

      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `ipv4-whitelisted-subnets-${new Date().toISOString()}.csv`;
      a.click();
      URL.revokeObjectURL(url);
    };

    cacheSubnetsButton.onclick = () => {
      cacheSubnets();
    };

    checkSubnetsButton.onclick = () => {
      checkSubnets();
    };

    saveButton.onclick = () => {
      saveResults();
    };

    document.addEventListener("DOMContentLoaded", async () => {
      const v = localStorage.getItem("ipv4-whitelisted-subnets_cachedSubnets");
      if (v) {
        cachedSubnets = JSON.parse(v);
        const total = Object.values(cachedSubnets).flat().length;
        console.log("cached subnets", cachedSubnets);
        checkSubnetsButton.disabled = false;
        status.textContent = "Ready (cached ‚ö°)";
        status.className = "status-ready";
        logPush("INFO", null, `Cached subnets loaded (providers: ${Object.keys(cachedSubnets).length}, total subnets: ${total}).`);
        return;
      }

      logPush("INFO", null, `Cached subnets not found.`);
    });
  </script>
</body>

</html>